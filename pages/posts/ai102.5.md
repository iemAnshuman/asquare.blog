---
title: Artificial Intelligence 102.5
date: 2025-09-21
type: note
---

### AI 102 in Action: The Case of the Martian Biosignature 🤖🪐

In our last post, we built the theoretical engine for a reasoning machine. Now, let's put that engine to the test with a complex, real-world scenario.

Imagine the Curiosity rover on Mars. It's not just a vehicle; it's a robotic scientist with a **Knowledge Base (KB)** of scientific facts. It just drilled a rock sample and now needs to determine if that sample contains evidence of life, based on its pre-programmed knowledge.

This is not a task for simple pattern matching; it requires a chain of logical deduction. Let's see how the rover uses Resolution and Unification to make a new discovery.

---

### The Scenario

- **Goal:** The rover, `Curiosity`, needs to prove that a sample, `RockA`, contains evidence of ancient life.
- **Query:** `EvidenceOfLife(RockA)`

---

### 1. The Knowledge Base (KB) in Predicate Logic

The rover has the following facts and rules programmed into its memory.

**Facts:**

1.  Curiosity is a rover: `Rover(Curiosity)`
2.  RockA is a sample: `Sample(RockA)`
3.  Curiosity drilled RockA: `Drilled(Curiosity, RockA)`
4.  RockA contains methane: `Contains(RockA, Methane)`
5.  Methane is an organic molecule: `Organic(Methane)`

**Rules (General Scientific Knowledge):** 6. Any sample that contains an organic molecule is considered a biosignature.
`∀x ∀y (Sample(x) ∧ Contains(x, y) ∧ Organic(y)) ⇒ Biosignature(x)` 7. If a sample is a biosignature, it is considered to have evidence of ancient life.
`∀x (Sample(x) ∧ Biosignature(x)) ⇒ EvidenceOfLife(x)`

---

### 2. The Proof: Step-by-Step Automated Reasoning

The rover's task is to prove `EvidenceOfLife(RockA)` is true given its KB. It will use proof by contradiction.

#### Step 2.1: Convert the KB to Clause Form (CNF)

First, every sentence must be converted into a standard clause.

- **C1:** `Rover(Curiosity)`
- **C2:** `Sample(RockA)`
- **C3:** `Drilled(Curiosity, RockA)`
- **C4:** `Contains(RockA, Methane)`
- **C5:** `Organic(Methane)`
- **C6:** `¬Sample(x) ∨ ¬Contains(x, y) ∨ ¬Organic(y) ∨ Biosignature(x)`
- **C7:** `¬Sample(x) ∨ ¬Biosignature(x) ∨ EvidenceOfLife(x)`

_(Note: The fact `Drilled(Curiosity, RockA)` isn't strictly necessary for this specific proof, but a real-world KB would contain many related facts.)_

#### Step 2.2: Negate the Goal

To begin the proof by contradiction, we assert the opposite of what we want to prove and add it to our set of clauses.

- **C8:** `¬EvidenceOfLife(RockA)`

Now, the stage is set. The rover will apply the Resolution algorithm repeatedly, hoping to derive the **empty clause ()**, which signifies a contradiction.

#### Step 2.3: The Resolution Process 🔬

Let's follow the rover's logical steps. It will combine clauses that contain complementary literals, using **Unification** to match variables.

**Resolution 1: Seeking evidence**

- The rover starts with its negated goal (**C8**) and looks for a clause to resolve it with. Clause **C7** contains `EvidenceOfLife(x)`.
- **Clauses:**
  - `¬Sample(x) ∨ ¬Biosignature(x) ∨ EvidenceOfLife(x)` (C7)
  - `¬EvidenceOfLife(RockA)` (C8)
- The literals `EvidenceOfLife(x)` and `¬EvidenceOfLife(RockA)` can be made complementary.
- **Unification:** The algorithm finds the Most General Unifier (MGU) `{x / RockA}`.
- **Result (C9):** Applying the substitution and resolving the clauses leaves us with a new clause: `¬Sample(RockA) ∨ ¬Biosignature(RockA)`

**Resolution 2: What makes a biosignature?**

- The new clause **C9** contains `¬Biosignature(RockA)`. The rover finds Clause **C6**, which contains `Biosignature(x)`.
- **Clauses:**
  - `¬Sample(x) ∨ ¬Contains(x, y) ∨ ¬Organic(y) ∨ Biosignature(x)` (C6)
  - `¬Sample(RockA) ∨ ¬Biosignature(RockA)` (C9)
- **Unification:** To match `Biosignature(x)` and `¬Biosignature(RockA)`, the MGU is `{x / RockA}`.
- **Result (C10):** We apply the substitution to both clauses and combine them, removing the `Biosignature` literals. Note that `¬Sample(RockA)` appears twice, but we only need to list it once.
  `¬Sample(RockA) ∨ ¬Contains(RockA, y) ∨ ¬Organic(y)`

**Resolution 3: Checking the sample's contents**

- Clause **C10** contains `¬Contains(RockA, y)`. The rover's KB has a fact about what `RockA` contains in **C4**.
- **Clauses:**
  - `¬Sample(RockA) ∨ ¬Contains(RockA, y) ∨ ¬Organic(y)` (C10)
  - `Contains(RockA, Methane)` (C4)
- **Unification:** To match `¬Contains(RockA, y)` and `Contains(RockA, Methane)`, the MGU is `{y / Methane}`.
- **Result (C11):** `¬Sample(RockA) ∨ ¬Organic(Methane)`

**Resolution 4: Confirming the sample**

- Clause **C11** has two negative literals. The rover can resolve `¬Sample(RockA)` with the simple fact in **C2**.
- **Clauses:**
  - `¬Sample(RockA) ∨ ¬Organic(Methane)` (C11)
  - `Sample(RockA)` (C2)
- **Unification:** No variables, this is a direct match.
- **Result (C12):** `¬Organic(Methane)`

**Resolution 5: The Final Contradiction**

- The rover is now left with a single literal in clause **C12**. It checks its KB and finds the direct opposite in **C5**.
- **Clauses:**
  - `¬Organic(Methane)` (C12)
  - `Organic(Methane)` (C5)
- **Result:** **The Empty Clause ()**

---

### 3. Conclusion: Discovery Made!

The rover has successfully derived the empty clause. This is a definitive logical contradiction. This proves that the initial assumption—that `RockA` did _not_ have evidence of life—must be false.

Therefore, the rover has logically proven that **`EvidenceOfLife(RockA)` is true.** It can now confidently transmit this new, derived knowledge back to mission control, having made a discovery not by seeing it directly, but by reasoning from the facts and rules it already knew.

This example, while simplified, shows the immense power of symbolic reasoning. By representing knowledge in a formal language and applying a single, powerful inference rule, an AI can navigate complex webs of facts to deduce new, non-obvious truths about its world.
