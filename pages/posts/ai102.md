---
title: Artificial Intelligence 102
date: 2025-09-21
type: note
---

## Propositional Logic (PL)

The simplest form of logic is **Propositional Logic**. It's a formal system built around **propositions**, which are declarative sentences that can be either **true** or **false**, but not both.

- `"It is raining."` (This can be true or false)
- `"The battery is full."` (This can be true or false)
- `"2 + 2 = 4"` (This is always true, so it's a valid proposition)

To build meaningful statements, we combine these symbols using a set of logical connectives.

| Connective        | Symbol | Meaning                 | Example                                                    |
| :---------------- | :----- | :---------------------- | :--------------------------------------------------------- |
| **Negation**      | $¬$    | NOT                     | `¬P` ("It is **not** raining.")                            |
| **Conjunction**   | $∧$    | AND                     | `P ∧ Q` ("It is raining **and** it is cloudy.")            |
| **Disjunction**   | $∨$    | OR                      | `P ∨ Q` ("It is raining **or** it is cloudy.")             |
| **Implication**   | $⇒$    | Implies (If... then...) | `P ⇒ Q` ("**If** it is raining, **then** it is cloudy.")   |
| **Biconditional** | $⇔$    | If and only if          | `P ⇔ Q` ("It is raining **if and only if** it is cloudy.") |

### Syntax and Semantics

Difference: Syntax is the set of rules for a language's grammar and structure, ensuring that expressions are correctly formed. Semantics, on the other hand, focuses on the meaning of those expressions, interpreting what they actually convey

The **semantics**, or meaning, of these connectives are defined by **truth tables**. These tables show the truth value of a complex sentence for every possible combination of truth values of its simple components. Here is the crucial truth table for implication ($⇒$):

|  P  |  Q  | P ⇒ Q |
| :-: | :-: | :---: |
|  F  |  F  |   T   |
|  F  |  T  |   T   |
|  T  |  F  |   F   |
|  T  |  T  |   T   |

### The Problem with Propositional Logic

Propositional logic is great, but it's fundamentally limited. It can't describe the world at a fine-grained level. Consider this famous argument:

1.  All humans are mortal.
2.  Socrates is a human.
3.  Therefore, Socrates is mortal.

In propositional logic, we'd have to assign this to symbols:

- P = "All humans are mortal."
- Q = "Socrates is a human."
- R = "Socrates is mortal."

There is no way within the rules of PL to connect P, Q, and R to derive the conclusion. The logic doesn't understand that "Socrates" is a specific instance of a "human" or that the property "mortal" applies to all humans. We need a richer language.

---

## Predicate Logic

**Predicate Logic**, also known as **First-Order Logic (FOL)**, extends propositional logic with more expressive components. It allows us to talk about **objects**, their **properties**, and the **relations** between them.

Here are its new building blocks:

- **Objects:** Refer to specific things in the world (e.g., `Socrates`, `Cat`, `House`).
- **Predicates:** Represent properties of objects or relations between them. A predicate is like a function that returns true or false. Examples:
  - `Human(Socrates)` - A property: "Socrates is a human."
  - `Brother(John, Richard)` - A relation: "John is the brother of Richard."
- **Quantifiers:** These are symbols that let us talk about groups of objects.
  - **Universal Quantifier (∀):** Means "For all..." or "For every...". It makes a statement about every object in the universe.
    > `∀x Human(x) ⇒ Mortal(x)`
    > (Reads: "For every object x, if x is a human, then x is mortal.")
  - **Existential Quantifier (∃):** Means "There exists..." or "For some...". It makes a statement about at least one object.
    > `∃x Cat(x) ∧ Likes(x, Fish)`
    > (Reads: "There exists an object x such that x is a cat and x likes fish.")

Now, with Predicate Logic, our Socrates argument is simple and logically sound. We can represent our knowledge and reason with it effectively.

---

## Resolution

Okay, so we have a powerful language to store knowledge. But how does an AI _use_ this knowledge to prove new things? We could define dozens of small inference rules (like Modus Ponens), but that's inefficient for a computer.

We need a single, powerful inference algorithm that is **complete** (meaning it can prove any provable statement). That algorithm is **Resolution**.

Resolution is a method for proving theorems by contradiction. The basic strategy is:

1.  Assume the **opposite** of what you want to prove.
2.  Show that this assumption, when combined with your existing knowledge, leads to an undeniable contradiction.
3.  Conclude that because your assumption led to a contradiction, it must be false. Therefore, the thing you originally wanted to prove must be true.

### Prerequisite: Clause Form

Resolution requires all our logical sentences to be in a standard format called **Clause Form** or **Conjunctive Normal Form (CNF)**. A sentence is in CNF if it's a set of **clauses** connected by ANDs, where each clause is a set of **literals** connected by ORs.

- A **literal** is an atomic proposition (like `P`) or its negation (`¬P`).
- A **clause** is a disjunction of literals (e.g., `(¬Human(x) ∨ Mortal(x))`).

Any sentence in propositional or predicate logic can be converted into CNF through a standard procedure. For our Socrates example, the knowledge becomes:

1.  `∀x Human(x) ⇒ Mortal(x)` converts to the clause `(¬Human(x) ∨ Mortal(x))`.
2.  `Human(Socrates)` is already the clause `(Human(Socrates))`.

### Resolution in Propositional Logic

The resolution rule is beautifully simple. If you have two clauses that contain a complementary literal (e.g., `P` and `¬P`), you can combine them and cancel out that pair.

For example, consider these two clauses:

1.  `(Cloudy ∨ Raining)`
2.  `(¬Cloudy ∨ Wet_Grass)`

Intuitively, we know that it's either cloudy or it isn't.

- If `Cloudy` is **false**, then from clause 1, `Raining` must be true.
- If `Cloudy` is **true**, then from clause 2, `Wet_Grass` must be true.
  Since `Cloudy` must be one or the other, we can conclude that **`(Raining ∨ Wet_Grass)`** must be true. This new clause is the **resolvent**.

### Resolution in Predicate Logic & The Unification Algorithm

In predicate logic, things get tricky because of variables. You can't resolve `(¬Human(x) ∨ Mortal(x))` with `(Human(Socrates))` because `x` and `Socrates` are not an exact complementary match.

This is where **Unification** comes in.

**Unification** is an algorithm for finding a **substitution** that makes two different logical expressions look identical. A substitution is a mapping of variables to terms.

Let's say we want to unify:

- `Knows(John, x)`
- `Knows(y, MotherOf(y))`

The unification algorithm finds the **Most General Unifier (MGU)**, which is the substitution that makes the expressions identical while being as general as possible. The MGU here would be `{y / John, x / MotherOf(John)}`. Applying this substitution gives us the identical expression `Knows(John, MotherOf(John))`.

### Putting It All Together: A Full Example

Let's use Resolution with Unification to formally prove that Socrates is mortal.

**1. Knowledge Base (KB) in Clause Form:**

- Clause 1: `(¬Human(x) ∨ Mortal(x))`
- Clause 2: `(Human(Socrates))`

**2. Goal to Prove:** `Mortal(Socrates)`

**3. Proof by Contradiction:**

- **Negate the goal:** `¬Mortal(Socrates)`. This becomes our third clause.
- **KB now contains:**
  1.  `(¬Human(x) ∨ Mortal(x))`
  2.  `(Human(Socrates))`
  3.  `(¬Mortal(Socrates))`

**4. Apply Resolution:**

- **Step A:** Let's resolve Clause 1 and Clause 3.

  - We want to match the literals `Mortal(x)` and `¬Mortal(Socrates)`.
  - Unification finds the MGU: `{x / Socrates}`.
  - Apply this substitution to Clause 1, which becomes `(¬Human(Socrates) ∨ Mortal(Socrates))`.
  - Now, resolve this with `(¬Mortal(Socrates))`. The complementary literals `Mortal(Socrates)` and `¬Mortal(Socrates)` cancel out.
  - **Our new resolvent is: `(¬Human(Socrates))`**.

- **Step B:** Our KB now effectively contains:

  1.  `(Human(Socrates))` (from the original KB)
  2.  `(¬Human(Socrates))` (the new clause we just derived)

- **Step C:** Resolve these two clauses. They are a direct contradiction. When you resolve `P` and `¬P`, you are left with nothing. This is called the **empty clause ()**.

**5. Conclusion:**
We have derived the empty clause! This signifies a contradiction. Our initial assumption—that `¬Mortal(Socrates)` was true—must be false. Therefore, the original goal, **`Mortal(Socrates)`**, is proven to be **true**.

---
